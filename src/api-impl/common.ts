// backend application server entry (which is generated by api declaration) common

import * as net from 'net';
import * as dayjs from 'dayjs';

export const dateFormat = 'YYYYMMDD';
export const timeFormat = 'YYYYMMDDHHmmdd';

// NOTE: sync with shared/types/auth.d.ts
export interface UserCredential {
    id: number,
    name: string,
    deviceId: number,
    deviceName: string,
}

export interface Context {
    user: UserCredential,
}

export type MyErrorType = 'common' | 'not-found' | 'auth' | 'unreachable' | 'method-not-allowed';
// not extend Error:
// super(message) in contructor will make json stringify not include that (not owned property)
// this ipc border need plain type, stacktrace for internal error should be handled by this program's error handling and log process
export class MyError {
    constructor(public readonly type: MyErrorType, public readonly message?: string) {
    }
}

export interface DispatchContext {
    method: string,
    // GET api.domain.com/app1/v1/getsomething
    //           this part:   ^^^^^^^^^^^^^^^^
    path: string,
    body: any,
    state: Context,
    status?: number,
    error?: MyError,
}

export function validateNumber(name: string, raw: string): number {
    const result = parseInt(raw);
    if (isNaN(result)) {
        throw new MyError('common', `invalid parameter ${name} value ${raw}`);
    }
    return result;
}

export function validateId(name: string, raw: string): number {
    const result = parseInt(raw);
    if (isNaN(result) || result <= 0) {
        throw new MyError('common', `invalid parameter ${name} value ${raw}`);
    }
    return result;
}

export function validateDate(name: string, raw: string): dayjs.Dayjs {
    const result = dayjs(raw, dateFormat);
    if (!result.isValid()) {
        throw new MyError('common', `invalid parameter ${name} value ${raw}`);
    }
    return result;
}

export function validateTime(name: string, raw: string): dayjs.Dayjs {
    const result = dayjs(raw, timeFormat);
    if (!result.isValid()) {
        throw new MyError('common', `invalid parameter ${name} value ${raw}`);
    }
    return result;
}

export function validateBody<T>(body: any): T {
    if (!body || Object.keys(body).length == 0) {
        throw new MyError('common', 'invalid empty body');
    }
    return body;
}

export function setupServer<T>(server: net.Server, connections: net.Socket[], dispatch: (ctx: DispatchContext, impl: T) => Promise<void>, impl: T) {
    server.on('error', error => {
        console.log(`socket server error: ${error.message}`);
    });
    server.on('connection', connection => {
        connections.push(connection);

        connection.on('close', () => {
            connections.splice(connections.indexOf(connection), 1);
        });
        connection.on('error', error => {
            console.log(`socket connection error: ${error.message}`);
        });
        connection.on('data', async data => {
            const payload = data.toString('utf-8');

            let ctx = {} as DispatchContext;
            try {
                ctx = JSON.parse(payload);
            } catch {
                console.log('socket server failed to parse payload: ' + payload);
            }

            try {
                await dispatch(ctx, impl);
            } catch (error) {
                ctx.error = error;
            } finally {
                delete ctx.path;
                delete ctx.state;
                delete ctx.method;
                connection.write(JSON.stringify(ctx));
            }
        });
    });
}

export function shutdownServer(server: net.Server, connections: net.Socket[]): Promise<void> {
    for (const socket of connections) {
        socket.destroy();
    }
    return new Promise<void>((resolve, reject) => server.close(error => {
        if (error) { console.log(`failed to close socket server: ${error.message}`); reject(); }
        else { resolve(); }
    }));
}
